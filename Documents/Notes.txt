BUGS
----
- onDataReceived: bad_weak_ptr
  - Start Gateway, TestClient.NET -sub-mixed, TestClient.NET -bub-mixed
  - Press Enter to stop the subscriber
  - The Gateway logs the error repeatedly (which stops if the publisher is stopped)

TODO
----
- Maxim's points:
  DONE - 1. No Version.
  - 2. No event on disconnect (or other errors) to raise an advisory. C++, C#
  DONE - 3. Can't send a message with a reply subject.
  DONE - 4. tryGet methods on Field and Message.
  DONE - 5. Field.getFieldType.
  DONE - 6. No max messages limit on PMQ.
  DONE - 7. No messages-dispatched count from PMQ.
  DONE - 8. No way to report the size of the queue.
  DONE - 9. try...catch in processGatewayMessage around client callbacks.

- Is ConnectionImpl::QueuedMessage copying the Header? Can we do anything about that?

- Rename Gateway -> MessagingMeshGateway

- Log the stack trace from exceptions. C++, C#

- Think about storing Message fields in a list / vector when we have a small 
  number of fields. This might be faster.

- Talk to Maxim (again) about string encoding - for both C++ and C#. Can this be the client's responsibility?

- Is it possible to use mimalloc by default in library code without the client having to link it?

- We do not need a thread safe queue in the gateway
  - ie, on a Service UV thread
  - We *do* still want to queue messages (to get the benefits of coalescing) but it does not need to be thread safe

- Hybrid hot mode for UV loop:
  - Run HOT by default. 
  - Switch to COLD only when messages are flowing continuously.
  - Switch back to HOT when we haven't seen messages for some (short, configurable?) amount of time, eg 100us.
  - Have config options for:
    - COLD
    - ALWAYS_HOT
    - HYBRID_HOT (the default?): Claude calls this ADAPTIVE, which I rather like
  - QUESTION: Does UV have some way of knowing whether the loop has been active recently?
    - Something to do with 'idle' maybe?
  - UV run options:
    - uv_run(m_loop.get(), UV_RUN_NOWAIT);
    - uv_run(m_loop.get(), UV_RUN_ONCE);
    - uv_run(m_loop.get(), UV_RUN_DEFAULT);  // Not 'manual' this keeps running

- Locking around the whole of Logger.log()?
  - And mandate that clients must not call MM functions in the log callback

- Optionally hold BufferPtr in UVUtilsWriteRequest
  - Use this for large messages
  - Avoid copying the buffer
  - Note: This cannot be used when we need to override the subscription ID
          ie, it can be used in client-side code but not in the gateway
          (at least, not for sending messages back to clients)

- C++ -pub with C# -sub works weirdly
  - Buffers lots of memory in the publisher
  - Doesn't work properly if the publisher or subscriber are restarted (with the same gateway)

- Is Connection thread safe?
  - Is the socket sending thread safe? eg, will sends from different threads get 'mixed up'? (Though they are queued to one thread?)
  - Can you subscribe from multiple threads? (C#, C++)
  - Can you send messages from multiple threads? (C#, C++)
  - Can you sendRequest from multiple threads? (C#, C++)

- Do the client side subscription cache thing for C#

- Maybe have a pool of inboxes on the client side?

- Think about pimpl vs C++20 modules

- Better disconnection handling
  - Not all cases of gateway and/or clients dying are handled well

- Clean up removed subscriptions from the interest-graph

- ConnectionImpl::m_subscriptions needs to be thread safe
  - I'm not convinced that the ConnectionImpl and Subscription dtors are properly thread safe

- Handle fast producers and slow consumers
  - What happens if a consumer is slow? Does it slow down publication from the Gateway to other clients?

- Profiling:
  - C# subscriber
  - C++ publisher
  - C++ subscriber

- Performance (C#)
  - AutoResetEvent.Set() looks slow.
  - Have another look at BlockingCollection<T> for the C# queues
  - Try Socket.Send(IList<ArraySegment<byte>>) instead of copying to one big byte[]
  - Is the Dictionary in Message slow? For small numbers of fields would checking the List be faster?
  - Sensitive to the initial Buffer size. The initial allocation is slow. 
    - Use a shared pool of byte[]???


Creating a messaging-mesh client
--------------------------------
- C++ -> General -> Additional Include Directories
MessagingMeshLib\headers

- Linker -> Input -> Additional Dependencies
MessagingMeshLib\lib\($Configuration)\MessagingMeshLib.lib
advapi32.lib
crypt32.lib
iphlpapi.lib
psapi.lib
shell32.lib
user32.lib
userenv.lib
ws2_32.lib
dbghelp.lib





