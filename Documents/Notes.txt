TODO
----
- Talk to Maxim (again) about string encoding - for both C++ and C#. Can this be the client's responsibility?

- Add tryGet methods to Field and Message for C++.

- Add (optional) replySubject to Connection.sendMessage

- Is it possible to use mimalloc by default in library code without the client having to link it?

- We do not need a thread safe queue in the gateway
  - ie, on a Service UV thread

- Hybrid hot mode for UV loop:
  - Run HOT by default. 
  - Switch to COLD only when messages are flowing continuously.
  - Switch back to HOT when we haven't seen messages for some (short, configurable?) amount of time, eg 100us.
  - Have config options for:
    - COLD
    - ALWAYS_HOT
    - HYBRID_HOT (the default?): Claude calls this ADAPTIVE, which I rather like
  - QUESTION: Does UV have some way of knowing whether the loop has been active recently?
    - Something to do with 'idle' maybe?
  - UV run options:
    - uv_run(m_loop.get(), UV_RUN_NOWAIT);
    - uv_run(m_loop.get(), UV_RUN_ONCE);
    - uv_run(m_loop.get(), UV_RUN_DEFAULT);  // Not 'manual' this keeps running

- Locking around the whole of Logger.log()?
  - And mandate that clients must not call MM functions in the log callback

- Require a ClientID to be passed with connection requests?
  - Use it (along with IP address + port) for the socket name

- Add blob tests to the C++ TestClient

- Optionally hold BufferPtr in UVUtilsWriteRequest
  - Use this for large messages
  - Avoid copying the buffer
  - Note: This cannot be used when we need to override the subscription ID
          ie, it can be used in client-side code but not in the gateway
          (at least, not for sending messages back to clients)

- C++ -pub with C# -sub works weirdly
  - Buffers lots of memory in the publisher
  - Doesn't work properly if the publisher or subscriber are restarted (with the same gateway)

- Is Connection thread safe?
  - Is the socket sending thread safe? eg, will sends from different threads get 'mixed up'? (Though they are queued to one thread?)
  - Can you subscribe from multiple threads? (C#, C++)
  - Can you send messages from multiple threads? (C#, C++)
  - Can you sendRequest from multiple threads? (C#, C++)

- Do the client side subscription cache thing for C#

- Maybe have a pool of inboxes on the client side?

- Think about pimpl vs C++20 modules

- Better disconnection handling
  - Not all cases of gateway and/or clients dying are handled well

- Clean up removed subscriptions from the interest-graph

- ConnectionImpl::m_subscriptions needs to be thread safe
  - I'm not convinced that the ConnectionImpl and Subscription dtors are properly thread safe

- Handle fast producers and slow consumers
  - What happens if a consumer is slow? Does it slow down publication from the Gateway to other clients?

- Profiling:
  - C# subscriber
  - C++ publisher
  - C++ subscriber

- Performance (C#)
  - AutoResetEvent.Set() looks slow.
  - Have another look at BlockingCollection<T> for the C# queues
  - Try Socket.Send(IList<ArraySegment<byte>>) instead of copying to one big byte[]
  - Is the Dictionary in Message slow? For small numbers of fields would checking the List be faster?
  - Sensitive to the initial Buffer size. The initial allocation is slow. 
    - Use a shared pool of byte[]???


Creating a messaging-mesh client
--------------------------------
- C++ -> General -> Additional Include Directories
MessagingMeshLib\headers

- Linker -> Input -> Additional Dependencies
MessagingMeshLib\lib\($Configuration)\MessagingMeshLib.lib
advapi32.lib
crypt32.lib
iphlpapi.lib
psapi.lib
shell32.lib
user32.lib
userenv.lib
ws2_32.lib
dbghelp.lib




How does the mesh work?
-----------------------
- Initially managed with config
  - List of all gateways in the mesh with their connection params, ie (host, port)

- Each gateway connects to each other gateway
  - Though not to themselves!

- Q: Should the connection to other gateways use the standard client connection?
  - A: I think No.
  - The standard client gets deserialized messages
  - Gateways do not need to do this to forward messages to other gateways

- How do subscriptions work?

- IMPORTANT: We need to avoid multiple updates when there are wildcard subscriptions
  - Example:
  - Client A subscribes to A.B, A.* via Gateway A
  - The subscriptions are forwarded to Gateway B
  - Client B connected to Gateway B publishes A.B
  - This matches both subscriptions: A.B and A.*
  - BUT: If we send both updates to Gateway A, it might then match them
         against its subscriptions and send each update to Client A.
         So Client A would get *four* updates instead of two.

- RULE: If a Gateway has multiple client subscriptions for a subject, the
        subscription is only sent once to other Gateways. So:
        - We send a subscription to other gateways when we get the *first* subscription for a subject
        - We send an unsubscribe when there are no subscriptnios remaining

- RULE: All updates are only sent between gateways once
  - Even if they match multiple subscriptions rules
  - The fan out for multiple subscriptions will be done by the receiving gateway

- Other gateways may not be up when a gateway wants to connect to them
  - Even if they all start "at the same time" they will not all start at exactly the same time

- Other gateways may become not available while the mesh is running
  - For example they may be restarted
  - Or the server they are on is restarted
  - Or they may be (semi) permanently unavailable, eg server failure

- So the gateway needs to cope with other gateways in the mesh coming and going
  - We need to make sure that subscriptions are up to date when gateways connect

- IDEA: Have a GatewayConnection class
  - Like the client Connection but for gateway-to-gateway connections
  - In particular it does not deserialize Buffers to Messages
  - It retries creating the connection to the peer gateway
  - It helps us to know that an update came from another gateway rather than from a real client

- IDEA: Have a GatewayConnectionManager
  - This reads the config
  - Creates one GatewayConnection for each peer gateway

- What is the relationship between the mesh and the Services?
  - The mesh config specifies the collection of gateways *per service*
  - There may be different gateways per service
    - eg, VULCAN running on one set of servers/gateways, RAMP on another set of servers/gateways
  - But: Different services may also be sharing servers/gateways
    - There could be some overlap
    - ie, not all services connect to the same gateways
      - But some different services do connect to the same gateways as other services

- So: Should the GatewayConnection be service-specific? Or gateway specific?

- The client Connection is both service and gateway specific
  - It connects to one gateway for one service
  - The socket for it is managed by the service UV loop at the gateway end

- QUESTION: What do we do when gateways connect? (Including reconnect.)
  - Q1: A gateway connects to a remote gateway
  - Q2: A gateway receives a connection from a remote gateway

- HANG ON A MOMENT: Do we really have two connections between each pair of gateways?
  - Does G1 connect to G2 *and* G2 connect to G1?
  - That seems sort of odd
  - Or does it make things simpler?

- Let's say that it makes things simpler...
  - For a start it means that each gateway can connect to each other one
  - If there was only one connection between each pair, there would need to be a way
    to work out which one would initiate it. (Though maybe not that hard.)
  - It will make connecting to a Service easier
    - Especially if the connection is similar to a client connection
    - The socket at the 'server' end will be assigned to the right UV loop

- GatewayConnection and UV loops / threading
  - Which loop / thread should the client end of the connection work on?
  - We want to receive updates for a service on the service's own UV loop
  - This could be done with the processMessageQueue mechanism
  - To do this we would want to PMQ all connections for a Service from the service's own loop

- IDEA: ServiceManager manages the mesh for that service
  - Instead of GatewayConnectionManager
  - Each ServiceManager reads the config (or whatever) and finds the mesh for that service
  - It then creates the GatewayConnections and processes them on that loop thread
  - BUT: How do we do this without blocking the thread?
    - We can do PMQ with a zero timeout
    - Or observe updates on the socket's thread and only then call PMQ?
    - Via a marshalled event?
  - This might need a sort of hybrid PMQ and threaded thing
    - ie, We get a callback on the socket thread that data is available
    - But *not* the data itself
    - This is the trigger to marshall the event
    - We call PMQ in the event

- OR simpler: We create the mesh sockets on the ServiceManager UV loop
  - But we don't get the benefit of write queuing / threading

- IDEA: GatewayConnection can just be ConnectionImpl
  - We don't need the pimpl abstraction of Connection
  - ConnectionImpl can be enhanced with 'internal' features for GatewayConnection
  - THOUGHT: I think this might not be a good idea
    - There is a bunch of stuff in ConnectionImpl not relevant to the GatewayConnection
    - And stuff that doesn't really work, like the reference to the parent Connection
    - If we need to share stuff, it could go into utility classes / functions

- Does sendRequest() work through the mesh?
  - Answer: Yes, I think so!
  - As long as everything is propagated in order
  - eg, the request inbox subscription before the subscription request
  - And they are all processed in order

No relay
--------
- RULE: We *do not* relay messages from peer gateways to (other) peer gateways
  - Gateways only relay *client messages* to peer gateways

- What does this mean for subscription propagation?
  - Only *client subscriptions* should be propagated to peer gateways


How do we initially create the mesh?
------------------------------------
- What happens when a gateway is started?
  - With regard to connecting to a mesh?

- At the moment, the gateway will only create a ServiceManager (and thus the mesh)
  when we get the first client connection for the Service

- We should create the mesh when the gateway starts up

- The MeshManager should work at *gateway level* 
  - Not just at Service level

- It reads the config 
  - (Or in a later version talks to a central service)
  - It works out which meshes the gateway is part of
    - (Maybe by converting hostnames to IP addresses and comparing with "our" IP address?)
  - It (pre-)starts the ServiceManager for each service

- The ServiceManager creates the MeshGatewayConnections for each peer in the mesh


Mesh config
-----------
- For the moment this will be a JSON text file.
  - Filename: mesh.config
  - Located in the same folder as Gateway.exe
  - Later it could itself be looked up from a service

- See example in Solution Items/mesh-config.json

- Parse with https://github.com/nlohmann/json

- We could have a MeshConfigProvider class which provides the config to code that needs it
  - Later this could read the data from a service
  - Later it could dynamically add and remove items from meshes


MeshManager
-----------
- Reads the config

- Creates one MeshGatewayConnection for each peer gateway
  - ie, each gateway in the mesh that is not "us"


MeshGatewayConnection
---------------------
- Connects to one peer gateway
  - Retries the connection at some interval




