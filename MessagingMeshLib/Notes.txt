TODO
----
- C++ -pub with C# -sub works weirdly
  - Buffers lots of memory in the publisher
  - Doesn't work properly if the publisher or subscriber are restarted (with the same gateway)

- Is Connection thread safe?
  - Is the socket sending thread safe? eg, will sends from different threads get 'mixed up'? (Though they are queued to one thread?)
  - Can you subscribe from multiple threads? (C#, C++)
  - Can you send messages from multiple threads? (C#, C++)
  - Can you sendRequest from multiple threads? (C#, C++)

- Do we need the wakeUp() thing? (A: Yes, when running in PMQ mode)

- Support field types (and add tests): 
  - Test serializing between languages (via binary files)

- Message::getAllField (C++, C#)

- Message::getField() non-const, ie so that you can modify a field (C++, C#) 

- Think about pimpl vs C++20 modules

- Better disconnection handling
  - Not all cases of gateway and/or clients dying are handled well

- ConnectionParams class (C++, C#)
  - Include whether to call back on the connection's thread or to need manual dispatch (PMQ)

- Clean up removed subscriptions from the interest-graph

- ConnectionImpl::m_subscriptions needs to be thread safe
  - I'm not convinced that the ConnectionImpl and Subscription dtors are properly thread safe

- Handle fast producers and slow consumers
  - What happens if a consumer is slow? Does it slow down publication from the Gateway to other clients?




Creating a messaging-mesh client
--------------------------------
- C++ -> General -> Additional Include Directories
MessagingMeshLib\headers

- Linker -> Input -> Additional Dependencies
MessagingMeshLib\lib\($Configuration)\MessagingMeshLib.lib
advapi32.lib
crypt32.lib
iphlpapi.lib
psapi.lib
shell32.lib
user32.lib
userenv.lib
ws2_32.lib
dbghelp.lib





How should BLOB work in C++?
----------------------------
- We could have a BLOB class holding
  - void* data
  - size_t length

- How does ownership of the data work?

- I think that sometimes the BLOB will own the data and sometime it will not
  - When it is read from a buffer it will own the data

- Can the BLOB be a view / slice into a Buffer?
  - If so, it is only valid while the Buffer is alive
  - But is a lot more efficient
  - But: I think that the Buffer will often be out of scope while the message holding the BLOB still alive
    - Unless the BLOB holds the BufferPtr, so keeps it alive

- Let's say that BLOB *never* owns its data
  - That sounds like it won't work

- How is BLOB used?

- Client code has a byte array
  - Maybe from binary serialization
  
- BLOB blob(data, length);
- pMessage->addBLOB("field-name", blob)

- *** The BLOB should be a shared pointer: BLOBPtr ***
  - So it can be passed in and out of messages and fields






