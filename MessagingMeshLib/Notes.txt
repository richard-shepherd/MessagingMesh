TODO
----
- Logger:
  - Better scope for locks (iterate over a copy of the callbacks)
  - try...catch
  - Check message for null

  - Do we need the wakeUp() thing?

  - Can we do the IEnumerable<byte> thing for C++ as well?

- Should we queue the NetworkMessages in the socket instead of the Buffers?
  - Then we can serialize them in the sending function into one large buffer

- Support field types (and add tests): 
  - BLOB (C++, C#): Change read_bytes, write_bytes to encode the size as well?
  - UNSIGNED_INT32 (C++, C#)

- ClientSocket: send more efficiently (combine buffers)

- Gateway is not handling socket closed or DISCONNECT from C# client
  - In particular if nothing else was done on the socket

- ConnectionParams class (C++, C#)
  - Include whether to call back on the connection's thread or to need manual dispatch (PMQ)

- Message::getFields() to get all fields (C++, C#)

- Connection must not make more than one subscription to the gateway for a
  subject. It should check if the subsciption has already been made and map
  the existing subscription ID to multiple callbacks if necessary.

- Support a Tag ('closure') for subscriptions, returned with callbacks

- Clean up removed subscriptions from the interest-graph

- ConnectionImpl::m_subscriptions needs to be thread safe

- Replace enum with enum class

- Handle fast producers and slow consumers

- I'm not convinced that the ConnectionImpl and Subscription dtors are properly thread safe

- Think about making Socket::write subscriptionIDOverride thing more generic?
  - ie, so that the (generic-ish) socket doesn't know such a specific detail


Creating a messaging-mesh client
--------------------------------
- C++ -> General -> Additional Include Directories
MessagingMeshLib\headers

- Linker -> Input -> Additional Dependencies
MessagingMeshLib\lib\($Configuration)\MessagingMeshLib.lib
advapi32.lib
crypt32.lib
iphlpapi.lib
psapi.lib
shell32.lib
user32.lib
userenv.lib
ws2_32.lib
dbghelp.lib








