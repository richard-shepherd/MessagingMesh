TODO
----
- Talk to Maxim (again) about string encoding - for both C++ and C#. Can this be the client's responsibility?

- Optionally hold BufferPtr in UVUtilsWriteRequest
  - Use this for large messages
  - Avoid copying the buffer
  - Note: This cannot be used when we need to override the subscription ID
          ie, it can be used in client-side code but not in the gateway
          (at least, not for sending messages back to clients)

- C++ -pub with C# -sub works weirdly
  - Buffers lots of memory in the publisher
  - Doesn't work properly if the publisher or subscriber are restarted (with the same gateway)

- Is Connection thread safe?
  - Is the socket sending thread safe? eg, will sends from different threads get 'mixed up'? (Though they are queued to one thread?)
  - Can you subscribe from multiple threads? (C#, C++)
  - Can you send messages from multiple threads? (C#, C++)
  - Can you sendRequest from multiple threads? (C#, C++)

- Do the client side subscription cache thing for C#

- Think about pimpl vs C++20 modules

- Better disconnection handling
  - Not all cases of gateway and/or clients dying are handled well

- Clean up removed subscriptions from the interest-graph

- ConnectionImpl::m_subscriptions needs to be thread safe
  - I'm not convinced that the ConnectionImpl and Subscription dtors are properly thread safe

- Handle fast producers and slow consumers
  - What happens if a consumer is slow? Does it slow down publication from the Gateway to other clients?

- Performance (C#)
  - AutoResetEvent.Set() looks slow.
  - Is the Dictionary in Message slow? For small numbers of fields would checking the List be faster?
  - Sensitive to the initial Buffer size. The initial allocation is slow. 
    - Use a shared pool of byte[]???


Creating a messaging-mesh client
--------------------------------
- C++ -> General -> Additional Include Directories
MessagingMeshLib\headers

- Linker -> Input -> Additional Dependencies
MessagingMeshLib\lib\($Configuration)\MessagingMeshLib.lib
advapi32.lib
crypt32.lib
iphlpapi.lib
psapi.lib
shell32.lib
user32.lib
userenv.lib
ws2_32.lib
dbghelp.lib




How does the mesh work?
-----------------------
- Initially managed with config
  - List of all gateways in the mesh with their connection params, ie (host, port)

- Each gateway connects to each other gateway
  - Though not to themselves!

- Q: Should the connection to other gateways use the standard client connection?
  - A: I think No.
  - The standard client gets deserialized messages
  - Gateways do not need to do this to forward messages to other gateways

- How do subscriptions work?

- IMPORTANT: We need to avoid multiple updates when there are wildcard subscriptions
  - Example:
  - Client A subscribes to A.B, A.* via Gateway A
  - The subscriptions are forwarded to Gateway B
  - Client B connected to Gateway B publishes A.B
  - This matches both subscriptions: A.B and A.*
  - BUT: If we send both updates to Gateway A, it might then match them
         against its subscriptions and send each update to Client A.
         So Client A would get *four* updates instead of two.

- RULE: If a Gateway has multiple client subscriptions for a subject, the
        subscription is only sent once to other Gateways. So:
        - We send a subscription to other gateways when we get the *first* subscription for a subject
        - We send an unsubscribe when there are no subscriptnios remaining

- RULE: All updates are only sent between gateways once
  - Even if they match multiple subscriptions rules
  - The fan out for multiple subscriptions will be done by the 





