TODO
----
- Talk to Maxim (again) about string encoding - for both C++ and C#. Can this be the client's responsibility?

- Add blob tests to the C++ TestClient

- Optionally hold BufferPtr in UVUtilsWriteRequest
  - Use this for large messages
  - Avoid copying the buffer
  - Note: This cannot be used when we need to override the subscription ID
          ie, it can be used in client-side code but not in the gateway
          (at least, not for sending messages back to clients)

- C++ -pub with C# -sub works weirdly
  - Buffers lots of memory in the publisher
  - Doesn't work properly if the publisher or subscriber are restarted (with the same gateway)

- Is Connection thread safe?
  - Is the socket sending thread safe? eg, will sends from different threads get 'mixed up'? (Though they are queued to one thread?)
  - Can you subscribe from multiple threads? (C#, C++)
  - Can you send messages from multiple threads? (C#, C++)
  - Can you sendRequest from multiple threads? (C#, C++)

- Do the client side subscription cache thing for C#

- Think about pimpl vs C++20 modules

- Better disconnection handling
  - Not all cases of gateway and/or clients dying are handled well

- Clean up removed subscriptions from the interest-graph

- ConnectionImpl::m_subscriptions needs to be thread safe
  - I'm not convinced that the ConnectionImpl and Subscription dtors are properly thread safe

- Handle fast producers and slow consumers
  - What happens if a consumer is slow? Does it slow down publication from the Gateway to other clients?

- Profiling:
  - C# subscriber
  - C++ publisher
  - C++ subscriber

- Performance (C#)
  - AutoResetEvent.Set() looks slow.
  - Is the Dictionary in Message slow? For small numbers of fields would checking the List be faster?
  - Sensitive to the initial Buffer size. The initial allocation is slow. 
    - Use a shared pool of byte[]???


Creating a messaging-mesh client
--------------------------------
- C++ -> General -> Additional Include Directories
MessagingMeshLib\headers

- Linker -> Input -> Additional Dependencies
MessagingMeshLib\lib\($Configuration)\MessagingMeshLib.lib
advapi32.lib
crypt32.lib
iphlpapi.lib
psapi.lib
shell32.lib
user32.lib
userenv.lib
ws2_32.lib
dbghelp.lib




How does the mesh work?
-----------------------
- Initially managed with config
  - List of all gateways in the mesh with their connection params, ie (host, port)

- Each gateway connects to each other gateway
  - Though not to themselves!

- Q: Should the connection to other gateways use the standard client connection?
  - A: I think No.
  - The standard client gets deserialized messages
  - Gateways do not need to do this to forward messages to other gateways

- How do subscriptions work?

- IMPORTANT: We need to avoid multiple updates when there are wildcard subscriptions
  - Example:
  - Client A subscribes to A.B, A.* via Gateway A
  - The subscriptions are forwarded to Gateway B
  - Client B connected to Gateway B publishes A.B
  - This matches both subscriptions: A.B and A.*
  - BUT: If we send both updates to Gateway A, it might then match them
         against its subscriptions and send each update to Client A.
         So Client A would get *four* updates instead of two.

- RULE: If a Gateway has multiple client subscriptions for a subject, the
        subscription is only sent once to other Gateways. So:
        - We send a subscription to other gateways when we get the *first* subscription for a subject
        - We send an unsubscribe when there are no subscriptnios remaining

- RULE: All updates are only sent between gateways once
  - Even if they match multiple subscriptions rules
  - The fan out for multiple subscriptions will be done by the 

- Other gateways may not be up when a gateway wants to connect to them
  - Even if they all start "at the same time" they will not all start at exactly the same time

- Other gateways may become not available while the mesh is running
  - For example they may be restarted
  - Or the server they are on is restarted
  - Or they may be (semi) permanently unavailable, eg server failure

- So the gateway needs to cope with other gateways in the mesh coming and going
  - We need to make sure that subscriptions are up to date when gateways connect

- IDEA: Have a GatewayConnection class
  - Like the client Connection but for gateway-to-gateway connections
  - In particular it does not deserialize Buffers to Messages
  - It retries creating the connection to the peer gateway
  - It helps us to know that an update came from another gateway rather than from a real client

- IDEA: Have a GatewayConnectionManager
  - This reads the config
  - Creates one GatewayConnection for each peer gateway

- What is the relationship between the mesh and the Services?
  - The mesh config specifies the collection of gateways *per service*
  - There may be different gateways per service
    - eg, VULCAN running on one set of servers/gateways, RAMP on another set of servers/gateways
  - But: Different services may also be sharing servers/gateways
    - There could be some overlap
    - ie, not all services connect to the same gateways
      - But some different services do connect to the same gateways as other services

- So: Should the GatewayConnection be service-specific? Or gateway specific?

- The client Connection is both service and gateway specific
  - It connects to one gateway for one service
  - The socket for it is managed by the service UV loop at the gateway end

- QUESTION: What do we do when gateways connect? (Including reconnect.)
  - Q1: A gateway connects to a remote gateway
  - Q2: A gateway receives a connection from a remote gateway

- HANG ON A MOMENT: Do we really have two connections between each pair of gateways?
  - Does G1 connect to G2 *and* G2 connect to G1?
  - That seems sort of odd
  - Or does it make things simpler?












